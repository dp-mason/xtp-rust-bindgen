// THIS FILE WAS GENERATED BY `xtp-rust-bindgen`. DO NOT EDIT.

#![allow(non_snake_case)]
use extism_pdk::*;
use serde::{Deserialize, Serialize};

fn return_error(e: Error) -> i32 {
    let err = format!("{:?}", e);
    let mem = extism_pdk::Memory::from_bytes(&err).unwrap();
    unsafe {
        extism_pdk::extism::error_set(mem.offset());
    }
    -1
}

macro_rules! try_input {
    () => {{
        let x = input();
        match x {
            Ok(x) => x,
            Err(e) => return return_error(e),
        }
    }}
}

macro_rules! try_input_json {
    () => {{
        let x = input();
        match x {
            Ok(Json(x)) => x,
            Err(e) => return return_error(e),
        }
    }}
}


<% schema.exports.forEach(ex => { -%>

#[no_mangle]
pub extern "C" fn <%= ex.name %>() -> i32 {
    <% if (ex.output && ex.output.contentType === "application/json") { %>
    let ret = crate::<%= camelToSnakeCase(ex.name) %>(<% if (ex.input) { %>  <% if (ex.input.contentType === "application/json") { %> try_input_json!() <% } else { %> try_input!() <% } %> <% } %>).and_then(|x| output(Json(x)));
    <% } else { %>
    let ret = crate::<%= camelToSnakeCase(ex.name) %>(<% if (ex.input) { %> <% if (ex.input.contentType === "application/json") { %> try_input_json!() <% } else { %> try_input!() <% } %> <% } %>).and_then(output);
    <% } %>
    match ret {
        Ok(()) => {
            0
        }
        Err(e) => {
            return_error(e)
        }
    }
}
<% }) %>

<% Object.values(schema.schemas).forEach(schema => { %>
    <% if (schema.enum) { %>
#[derive(Serialize, Deserialize, FromBytes, ToBytes)]
#[encoding(Json)]
pub enum <%= capitalize(schema.name) %> {
    <% schema.enum.forEach(variant => { -%>
    #[serde(rename = "<%- variant %>")]
    <%= capitalize(variant) %>,
		<% }) %>
}
    <% } else { %>
#[derive(Serialize, Deserialize, FromBytes, ToBytes)]
#[encoding(Json)]
pub struct <%= capitalize(schema.name) %> {
    <% schema.properties.forEach(p => { -%>
		<% if (p.description) { -%>
		// <%- formatCommentBlock(p.description, "// ") %>
		<% } -%>
    #[serde(rename = "<%= p.name %>")]
    <% if (p.nullable) { %>#[serde(default)]<% } %>
		<%= makePublic(camelToSnakeCase(p.name)) %>: <%- p.nullable ? `Option<${toRustType(p)}>` : toRustType(p) %>,
		<% }) %>

    <% if (schema.additionalProperties) { %>
    #[serde(flatten)]
    additional_properties: std::collections::HashMap<String, <%- schema.additionalProperties.type ? toRustType(schema.additionalProperties.type) : "serde_json::Value" %>>,
    <% } %>
}
    <% } %>
<% }); %>

<% schema.imports.forEach(imp => { %>

<% if (hasComment(imp)) -%>
// <%= imp.name %> <%= formatCommentBlock(imp.description, "// ") %>
<% if (hasComment(imp.input)) { -%>
// It takes input of <%- toRustType(imp.input) %> (<%- formatCommentLine(imp.input.description) %>)
<% } -%>
<% if (hasComment(imp.output)) { -%>
// And it returns an output <%- toRustType(imp.output) %> (<%- formatCommentLine(imp.output.description) %>)
<% } -%>
#[host_fn]
extern "ExtismHost" {
    pub(crate) fn <%= imp.name %>(<% if (imp.input) { -%>input: <%- jsonWrappedRustType(imp.input) %><%} -%>) <% if (imp.output) { -%> -> <%- jsonWrappedRustType(imp.output) %><% } -%>;
} 

<% }) %>

